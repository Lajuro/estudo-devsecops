name: Build
on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened]
jobs:
  sonarqube:
    name: SonarQube
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
      
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v6
        with:
          args: >
            -Dsonar.qualitygate.wait=true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      
      - name: üìä Gerar Relat√≥rio SonarQube Detalhado
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const http = require('http');
            const https = require('https');
            
            // Configura√ß√µes
            const sonarToken = process.env.SONAR_TOKEN;
            const sonarUrl = process.env.SONAR_HOST_URL || 'http://localhost:9000';
            const projectKey = process.env.SONAR_PROJECT_KEY || 'nodejs-devsecops';
            
            console.log(`üîç Conectando ao SonarQube: ${sonarUrl}`);
            console.log(`üì¶ Projeto: ${projectKey}`);
            
            // Fun√ß√£o para fazer requisi√ß√µes ao SonarQube (HTTP/HTTPS)
            function fetchSonarData(endpoint) {
              return new Promise((resolve, reject) => {
                try {
                  const auth = Buffer.from(`${sonarToken}:`).toString('base64');
                  const url = new URL(endpoint, sonarUrl);
                  const protocol = url.protocol === 'https:' ? https : http;
                  
                  const options = {
                    hostname: url.hostname,
                    port: url.port || (url.protocol === 'https:' ? 443 : 80),
                    path: url.pathname + url.search,
                    method: 'GET',
                    headers: {
                      'Authorization': `Basic ${auth}`,
                      'Accept': 'application/json'
                    }
                  };
                  
                  const req = protocol.request(options, (res) => {
                    let data = '';
                    res.on('data', chunk => data += chunk);
                    res.on('end', () => {
                      try {
                        const json = JSON.parse(data);
                        console.log(`‚úÖ Resposta recebida (status ${res.statusCode})`);
                        resolve(json);
                      } catch (e) {
                        console.error(`‚ùå Erro ao parsear JSON:`, e.message);
                        console.error(`Resposta recebida:`, data.substring(0, 500));
                        reject(e);
                      }
                    });
                  });
                  
                  req.on('error', (err) => {
                    console.error(`‚ùå Erro na requisi√ß√£o:`, err.message);
                    reject(err);
                  });
                  
                  req.end();
                } catch (e) {
                  console.error(`‚ùå Erro ao criar requisi√ß√£o:`, e.message);
                  reject(e);
                }
              });
            }
            
            try {
              // Buscar informa√ß√µes do projeto
              console.log(`üìä Buscando m√©tricas do projeto...`);
              const projectMetrics = await fetchSonarData(`/api/measures/component?component=${projectKey}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,security_rating,reliability_rating,maintainability_rating`);
              
              if (!projectMetrics.component) {
                throw new Error(`Projeto "${projectKey}" n√£o encontrado no SonarQube`);
              }
              
              const measures = (projectMetrics.component.measures || []).reduce((acc, m) => {
                acc[m.metric] = m.value;
                return acc;
              }, {});
              
              // Buscar issues
              console.log(`üîç Buscando issues do projeto...`);
              const issuesResponse = await fetchSonarData(`/api/issues/search?componentKeys=${projectKey}&types=BUG,VULNERABILITY,CODE_SMELL&ps=100`);
              
              const issues = issuesResponse.issues || [];
              console.log(`‚úÖ ${issues.length} issues encontradas`);
              
              // Contar issues por tipo
              const bugCount = issues.filter(i => i.type === 'BUG').length;
              const vulnCount = issues.filter(i => i.type === 'VULNERABILITY').length;
              const smellCount = issues.filter(i => i.type === 'CODE_SMELL').length;
              
              // Contar por severidade
              const severities = issues.reduce((acc, i) => {
                acc[i.severity] = (acc[i.severity] || 0) + 1;
                return acc;
              }, {});
              
              // Gerar markdown report
              let report = `# üìã Relat√≥rio de An√°lise SonarQube\n\n`;
              report += `**Data:** ${new Date().toLocaleString('pt-BR')}\n`;
              report += `**Projeto:** ${projectKey}\n\n`;
              
              // Status geral
              report += `## üìä M√©tricas Gerais\n\n`;
              report += `| M√©trica | Valor |\n`;
              report += `|---------|-------|\n`;
              report += `| üêõ Bugs | ${measures.bugs || '0'} |\n`;
              report += `| üîí Vulnerabilidades | ${measures.vulnerabilities || '0'} |\n`;
              report += `| üí° Code Smells | ${measures.code_smells || '0'} |\n`;
              report += `| üìà Cobertura de Testes | ${measures.coverage || 'N/A'} |\n`;
              report += `| üîÅ Linhas Duplicadas | ${measures.duplicated_lines_density || 'N/A'} |\n`;
              report += `| ‚≠ê Rating de Seguran√ßa | ${measures.security_rating || 'N/A'} |\n`;
              report += `| üéØ Rating de Confiabilidade | ${measures.reliability_rating || 'N/A'} |\n`;
              report += `| üßπ Rating de Manutenibilidade | ${measures.maintainability_rating || 'N/A'} |\n\n`;
              
              // Resumo de issues
              report += `## üîç Resumo de Issues\n\n`;
              report += `- **Total de Issues:** ${issues.length}\n`;
              report += `- **Bugs:** ${bugCount}\n`;
              report += `- **Vulnerabilidades:** ${vulnCount}\n`;
              report += `- **Code Smells:** ${smellCount}\n\n`;
              
              if (Object.keys(severities).length > 0) {
                report += `### Por Severidade\n`;
                report += `| Severidade | Quantidade |\n`;
                report += `|------------|------------|\n`;
                Object.entries(severities).forEach(([sev, count]) => {
                  const icon = sev === 'BLOCKER' ? 'üî¥' : sev === 'CRITICAL' ? 'üü†' : sev === 'MAJOR' ? 'üü°' : sev === 'MINOR' ? 'üîµ' : '‚ö™';
                  report += `| ${icon} ${sev} | ${count} |\n`;
                });
                report += '\n';
              }
              
              // Top 10 issues mais graves
              if (issues.length > 0) {
                report += `## ‚ö†Ô∏è Issues Mais Graves\n\n`;
                const sorted = issues
                  .sort((a, b) => {
                    const severityOrder = { BLOCKER: 0, CRITICAL: 1, MAJOR: 2, MINOR: 3, INFO: 4 };
                    return severityOrder[a.severity] - severityOrder[b.severity];
                  })
                  .slice(0, 10);
                
                sorted.forEach((issue, idx) => {
                  const icon = issue.severity === 'BLOCKER' ? 'üî¥' : 
                               issue.severity === 'CRITICAL' ? 'üü†' : 
                               issue.severity === 'MAJOR' ? 'üü°' : 
                               issue.severity === 'MINOR' ? 'üîµ' : '‚ö™';
                  const typeIcon = issue.type === 'BUG' ? 'üêõ' : 
                                   issue.type === 'VULNERABILITY' ? 'üîí' : 'üí°';
                  
                  const fileName = issue.component ? issue.component.split(':').pop() : 'Desconhecido';
                  
                  report += `\n### ${idx + 1}. ${icon} ${typeIcon} ${issue.message}\n`;
                  report += `- **Arquivo:** \`${fileName}\`\n`;
                  if (issue.line) report += `- **Linha:** ${issue.line}\n`;
                  report += `- **Severidade:** ${issue.severity}\n`;
                  report += `- **Status:** ${issue.status}\n`;
                });
                report += '\n';
              } else {
                report += `## ‚úÖ Nenhuma Issue Encontrada\n\n`;
                report += `Excelente! Seu c√≥digo n√£o possui bugs, vulnerabilidades ou code smells cr√≠ticos.\n\n`;
              }
              
              // Links √∫teis
              report += `## üîó Links √öteis\n\n`;
              report += `- [üîó Abrir no SonarQube](${sonarUrl}/dashboard?id=${projectKey})\n`;
              report += `- [üìù Issues Completas](${sonarUrl}/issues?id=${projectKey})\n`;
              report += `- [üìä M√©tricas Detalhadas](${sonarUrl}/component_measures?id=${projectKey})\n\n`;
              
              // Recomenda√ß√µes
              report += `## üí° Recomenda√ß√µes\n\n`;
              if (vulnCount > 0) {
                report += `‚ö†Ô∏è **Prioridade Alta:** Existem ${vulnCount} vulnerabilidade(s) de seguran√ßa que precisam ser corrigidas imediatamente.\n\n`;
              }
              if (bugCount > 0) {
                report += `üîß **A√ß√£o Necess√°ria:** ${bugCount} bug(s) detectado(s). Revisar e corrigir √© essencial.\n\n`;
              }
              if (smellCount > 0) {
                report += `‚ú® **Melhorias:** ${smellCount} code smell(s) encontrado(s). Considere refatorar para melhor qualidade do c√≥digo.\n\n`;
              }
              if (vulnCount === 0 && bugCount === 0 && smellCount === 0) {
                report += `‚ú® **Parab√©ns!** Seu c√≥digo est√° em excelente estado.\n\n`;
              }
              
              // Escrever no arquivo de summary
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, report);
              
              console.log('‚úÖ Relat√≥rio gerado com sucesso!');
            } catch (error) {
              console.error('‚ùå Erro ao gerar relat√≥rio:', error.message);
              
              // Escrever um relat√≥rio de erro
              let errorReport = `# ‚ùå Erro ao Gerar Relat√≥rio SonarQube\n\n`;
              errorReport += `**Erro:** ${error.message}\n\n`;
              errorReport += `### üîß Verifica√ß√µes Necess√°rias\n\n`;
              errorReport += `1. Certifique-se que \`SONAR_TOKEN\` est√° configurado nos secrets\n`;
              errorReport += `2. Verifique se \`SONAR_HOST_URL\` est√° configurado (ex: \`http://localhost:9000\`)\n`;
              errorReport += `3. Confirme que a an√°lise SonarQube foi executada corretamente\n`;
              errorReport += `4. Valide que o \`SONAR_PROJECT_KEY\` est√° correto\n\n`;
              errorReport += `**URL do SonarQube:** ${process.env.SONAR_HOST_URL || 'n√£o configurado'}\n`;
              errorReport += `**Project Key:** ${projectKey}\n`;
              errorReport += `**Token:** ${sonarToken ? '‚úì Configurado' : '‚úó N√£o configurado'}\n`;
              
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, errorReport);
              
              // N√£o falha o workflow, apenas avisa
            }
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_PROJECT_KEY: nodejs-devsecops