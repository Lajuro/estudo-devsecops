name: Build
on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened]
jobs:
  sonarqube:
    name: SonarQube
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
      
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v6
        with:
          args: >
            -Dsonar.qualitygate.wait=true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      
      - name: üìä Gerar Relat√≥rio SonarQube Detalhado
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const https = require('https');
            
            // Configura√ß√µes
            const sonarToken = process.env.SONAR_TOKEN;
            const sonarUrl = process.env.SONAR_HOST_URL || 'http://localhost:9000';
            const projectKey = process.env.SONAR_PROJECT_KEY || 'nodejs-devsecops';
            
            // Fun√ß√£o para fazer requisi√ß√µes ao SonarQube
            function fetchSonarData(endpoint) {
              return new Promise((resolve, reject) => {
                const auth = Buffer.from(`${sonarToken}:`).toString('base64');
                const url = new URL(endpoint, sonarUrl);
                
                const options = {
                  hostname: url.hostname,
                  port: url.port,
                  path: url.pathname + url.search,
                  method: 'GET',
                  headers: {
                    'Authorization': `Basic ${auth}`,
                    'Accept': 'application/json'
                  }
                };
                
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      resolve(JSON.parse(data));
                    } catch (e) {
                      reject(e);
                    }
                  });
                });
                
                req.on('error', reject);
                req.end();
              });
            }
            
            try {
              // Buscar informa√ß√µes do projeto
              const projectMetrics = await fetchSonarData(`/api/measures/component?component=${projectKey}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,security_rating,reliability_rating,maintainability_rating`);
              
              const measures = projectMetrics.component.measures.reduce((acc, m) => {
                acc[m.metric] = m.value;
                return acc;
              }, {});
              
              // Buscar issues
              const issues = await fetchSonarData(`/api/issues/search?componentKeys=${projectKey}&types=BUG,VULNERABILITY,CODE_SMELL&ps=50`);
              
              // Contar issues por tipo
              const bugCount = issues.issues.filter(i => i.type === 'BUG').length;
              const vulnCount = issues.issues.filter(i => i.type === 'VULNERABILITY').length;
              const smellCount = issues.issues.filter(i => i.type === 'CODE_SMELL').length;
              
              // Contar por severidade
              const severities = issues.issues.reduce((acc, i) => {
                acc[i.severity] = (acc[i.severity] || 0) + 1;
                return acc;
              }, {});
              
              // Gerar markdown report
              let report = `# üìã Relat√≥rio de An√°lise SonarQube\n\n`;
              report += `**Data:** ${new Date().toLocaleString('pt-BR')}\n\n`;
              
              // Status geral
              report += `## üìä M√©tricas Gerais\n\n`;
              report += `| M√©trica | Valor |\n`;
              report += `|---------|-------|\n`;
              report += `| üêõ Bugs | ${measures.bugs || '0'} |\n`;
              report += `| üîí Vulnerabilidades | ${measures.vulnerabilities || '0'} |\n`;
              report += `| üí° Code Smells | ${measures.code_smells || '0'} |\n`;
              report += `| üìà Cobertura de Testes | ${measures.coverage || 'N/A'} |\n`;
              report += `| üîÅ Linhas Duplicadas | ${measures.duplicated_lines_density || 'N/A'} |\n`;
              report += `| ‚≠ê Rating de Seguran√ßa | ${measures.security_rating || 'N/A'} |\n`;
              report += `| üéØ Rating de Confiabilidade | ${measures.reliability_rating || 'N/A'} |\n`;
              report += `| üßπ Rating de Manutenibilidade | ${measures.maintainability_rating || 'N/A'} |\n\n`;
              
              // Resumo de issues
              report += `## üîç Resumo de Issues\n\n`;
              report += `- **Total de Issues:** ${issues.issues.length}\n`;
              report += `- **Bugs:** ${bugCount}\n`;
              report += `- **Vulnerabilidades:** ${vulnCount}\n`;
              report += `- **Code Smells:** ${smellCount}\n\n`;
              
              if (Object.keys(severities).length > 0) {
                report += `### Por Severidade\n`;
                report += `| Severidade | Quantidade |\n`;
                report += `|------------|------------|\n`;
                Object.entries(severities).forEach(([sev, count]) => {
                  const icon = sev === 'BLOCKER' ? 'üî¥' : sev === 'CRITICAL' ? 'üü†' : sev === 'MAJOR' ? 'üü°' : sev === 'MINOR' ? 'üîµ' : '‚ö™';
                  report += `| ${icon} ${sev} | ${count} |\n`;
                });
                report += '\n';
              }
              
              // Top 10 issues mais graves
              if (issues.issues.length > 0) {
                report += `## ‚ö†Ô∏è Issues Mais Graves\n\n`;
                const sorted = issues.issues
                  .sort((a, b) => {
                    const severityOrder = { BLOCKER: 0, CRITICAL: 1, MAJOR: 2, MINOR: 3, INFO: 4 };
                    return severityOrder[a.severity] - severityOrder[b.severity];
                  })
                  .slice(0, 10);
                
                sorted.forEach((issue, idx) => {
                  const icon = issue.severity === 'BLOCKER' ? 'üî¥' : 
                               issue.severity === 'CRITICAL' ? 'üü†' : 
                               issue.severity === 'MAJOR' ? 'üü°' : 
                               issue.severity === 'MINOR' ? 'üîµ' : '‚ö™';
                  const typeIcon = issue.type === 'BUG' ? 'üêõ' : 
                                   issue.type === 'VULNERABILITY' ? 'üîí' : 'üí°';
                  
                  report += `\n### ${idx + 1}. ${icon} ${typeIcon} ${issue.message}\n`;
                  report += `- **Arquivo:** \`${issue.component.split(':').pop()}\`\n`;
                  report += `- **Linha:** ${issue.line}\n`;
                  report += `- **Severidade:** ${issue.severity}\n`;
                  report += `- **Status:** ${issue.status}\n`;
                });
                report += '\n';
              }
              
              // Links √∫teis
              report += `## üîó Links √öteis\n\n`;
              report += `- [üîó Abrir no SonarQube](${sonarUrl}/dashboard?id=${projectKey})\n`;
              report += `- [üìù Issues Completas](${sonarUrl}/issues?id=${projectKey})\n`;
              report += `- [üìä M√©tricas Detalhadas](${sonarUrl}/component_measures?id=${projectKey})\n\n`;
              
              // Recomenda√ß√µes
              report += `## üí° Recomenda√ß√µes\n\n`;
              if (vulnCount > 0) {
                report += `‚ö†Ô∏è **Prioridade Alta:** Existem ${vulnCount} vulnerabilidade(s) de seguran√ßa que precisam ser corrigidas imediatamente.\n\n`;
              }
              if (bugCount > 0) {
                report += `üîß **A√ß√£o Necess√°ria:** ${bugCount} bug(s) detectado(s). Revisar e corrigir √© essencial.\n\n`;
              }
              if (smellCount > 0) {
                report += `‚ú® **Melhorias:** ${smellCount} code smell(s) encontrado(s). Considere refatorar para melhor qualidade do c√≥digo.\n\n`;
              }
              
              // Escrever no arquivo de summary
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, report);
              
              console.log('‚úÖ Relat√≥rio gerado com sucesso!');
            } catch (error) {
              console.error('‚ùå Erro ao gerar relat√≥rio:', error.message);
              // N√£o falha o workflow, apenas avisa
            }
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: nodejs-devsecops