name: Inicializa√ß√£o do Sistema
run-name: ${{ github.error }} est√° testando Actions üöÄ

env:
  AMBIENTE_ALVO: Producao

# Gatilhos de Evento
on:
  push:
    branches: [ "main" ]
  workflow_dispatch: # Permite execu√ß√£o manual via UI

jobs:
  analise-contextual:
    runs-on: ubuntu-latest
    steps:
      - name: Dump do Contexto GitHub
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo "$GITHUB_CONTEXT"

      - name: Execu√ß√£o Condicional
        # Evita rodar para commits de "Merge pull request" (mesclagens via PR)
        if: github.event_name == 'push' && !contains(github.event.head_commit.message || '', 'Merge pull request')
        run: echo "Este passo roda apenas em pushes diretos, n√£o em merges de pull requests."
  verificacao_ambiente:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do C√≥digo
        uses: actions/checkout@v4
        # A a√ß√£o do checkout √© fundamental; sem ela, o runner √© uma caixa vazia.
        # Ela baixa seu c√≥digo para o diret√≥rio de trabalho do runner.
      - name: Inspe√ß√£o do Sistema
        run: |
          echo "Sistema Operacional: $(uname -a)"
          echo "Node Version: $(node -v)"
          echo "Diret√≥rio Atual: $(pwd)"
          echo "Listando todos os arquivos e diret√≥rios recursivamente:"
          ls -laR
      - name: Listar arquivos (respeitando .listignore ou .gitignore)
        run: |
          echo "Listando arquivos excluindo padr√µes (suporta .listignore ou .gitignore)..."
          if [ -f .listignore ]; then
            echo ".listignore encontrado, usando-o para excluir padr√µes"
            python3 - <<'PY'
import fnmatch,os
patterns=[l.strip() for l in open('.listignore') if l.strip() and not l.strip().startswith('#')]
for root,dirs,files in os.walk('.'):
    # gerencia caminhos relativos
    for name in files:
        rel=os.path.relpath(os.path.join(root,name),'.')
        if rel=='.':
            continue
        skip=False
        for p in patterns:
            if fnmatch.fnmatch(rel,p) or fnmatch.fnmatch(os.path.join('/',rel),p):
                skip=True
                break
        if not skip:
            print(rel)
PY
          elif [ -d .git ]; then
            echo ".git encontrado, usando git ls-files para respeitar .gitignore"
            git ls-files -z --cached --others --exclude-standard | xargs -0 -n1
          else
            echo "Nenhum arquivo de ignore encontrado; listando todos os arquivos"
            find . -path './.git' -prune -o -print
          fi